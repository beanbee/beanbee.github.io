<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="database/sql包使用须知"><meta name="keywords" content="Golang"><meta name="author" content="Ian"><meta name="copyright" content="Ian"><title>database/sql包使用须知 | Beanbee's Blog</title><link rel="shortcut icon" href="/images/favicon.png"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?7d4742d910f55cfca7b3b16d97046c4e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.2'
} </script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/blog/atom.xml" title="Beanbee's Blog" type="application/atom+xml">
</head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="false"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.</span> <span class="toc-text">关于驱动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">2.</span> <span class="toc-text">连接池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AE%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.1.</span> <span class="toc-text">1. 设置连接池的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">2.2.</span> <span class="toc-text">2. 连接的分配策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%8F%8A%E6%97%B6%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.3.</span> <span class="toc-text">3. 及时释放连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%A2%E5%A4%B1%E8%BF%9E%E6%8E%A5%E5%B1%9E%E6%80%A7"><span class="toc-number">2.4.</span> <span class="toc-text">4. 丢失连接属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Prepared-Statements"><span class="toc-number">3.</span> <span class="toc-text">使用Prepared Statements</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%B9%B6%E5%8F%91Stmt%E5%AF%BC%E8%87%B4%E8%BF%9E%E6%8E%A5%E7%AA%81%E5%A2%9E"><span class="toc-number">3.1.</span> <span class="toc-text">1. 并发Stmt导致连接突增</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8D%A0%E4%BD%8D%E7%AC%A6%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">2. 占位符区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%8B%E5%8A%A1%E4%B8%AD%E4%BD%BF%E7%94%A8PS"><span class="toc-number">3.3.</span> <span class="toc-text">3. 事务中使用PS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1Tx"><span class="toc-number">4.</span> <span class="toc-text">使用事务Tx</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Multiple-Statement%E6%94%AF%E6%8C%81"><span class="toc-number">4.1.</span> <span class="toc-text">1. Multiple Statement支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84Tx"><span class="toc-number">4.2.</span> <span class="toc-text">2. 并发场景下的Tx</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/images/favicon.png"></div><div class="author-info__name text-center">Ian</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">21</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Blogroll</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://kingsamchen.github.io/">kingsamchen</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://madstrawberry.me/">madstrawberry</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://functionghw.is-programmer.com">FunctionGHW</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://blog.51cto.com/ytyzzm">JamesSong</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="http://sunus.me/">Sunus</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/images/default_top_image_beanbee.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Beanbee's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title">database/sql包使用须知</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-06-26</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/codeblock/">codeblock</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>Golang的database&#x2F;sql包为SQL类数据库提供了通用的API操作，它简化了对不同数据库driver的依赖，总体来说是使用简单、操作可靠同时维持了代码的扩展性，不过在使用过程中仍然有一些陷阱和误区，本文就记录下使用database&#x2F;sql过程中的一些注意点，穿插一部分实现。文中部分例子来自database&#x2F;sql的<a target="_blank" rel="noopener" href="http://go-database-sql.org/">使用说明</a>，示例Go版本1.6。</p>
<p>database&#x2F;sql包的结构其实就分为驱动接口(driver)和DB操作(sql)两部分。源码并没有实现任何一种数据库的驱动，提倡以实现database&#x2F;sql&#x2F;driver包的形式来注册第三方的DB驱动，对开发者尽可能的屏蔽特定数据库的feature，算是go的一贯风格吧；如果你使用的SQLite、MySQL、PG这样的数据库，直接使用database&#x2F;sql就可以完成绝大部分DB操作。</p>
<h1 id="关于驱动"><a href="#关于驱动" class="headerlink" title="关于驱动"></a>关于驱动</h1><p>如上，数据库的驱动是第三方实现的，在Go里面，通过匿名导入的方式注册一个附加的driver这种方式很常见，下面就是MySQL的注册方式：</p>
<span id="more"></span>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MySQL驱动&quot;github.com/go-sql-driver/mysql&quot;的init函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sql.Register(<span class="string">&quot;mysql&quot;</span>, &amp;MySQLDriver&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// database/sql中记录驱动映射关系的map</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	driversMu sync.RWMutex</span><br><span class="line">	drivers   = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]driver.Driver)</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 实际使用中引入MySQL驱动</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;database/sql&quot;</span></span><br><span class="line"> </span><br><span class="line">	_ <span class="string">&quot;github.com/go-sql-driver/mysql&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	db, err := sql.Open(<span class="string">&quot;mysql&quot;</span>, <span class="string">&quot;xxx@xxx:xxx&quot;</span>)</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里主要讲下database&#x2F;sql&#x2F;driver这个包（后面用driver包代替）的内容，driver包通常不被直接使用，源码中database&#x2F;sql是它的一种实现，写自定义驱动的时候要按照driver包的内容实现所有的interface，看几个重要的接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Value代表一个database/sql认识的数据库字段类型.</span></span><br><span class="line"><span class="comment">// 它要不为nil，或者作为Go以下原生类型的实例形式：</span></span><br><span class="line"><span class="comment">//   int64</span></span><br><span class="line"><span class="comment">//   float64</span></span><br><span class="line"><span class="comment">//   bool</span></span><br><span class="line"><span class="comment">//   []byte</span></span><br><span class="line"><span class="comment">//   string   [*] everywhere except from Rows.Next.</span></span><br><span class="line"><span class="comment">//   time.Time</span></span><br><span class="line"><span class="keyword">type</span> Value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 任何一个数据库驱动必须实现Driver接口，注册的时候就靠它</span></span><br><span class="line"><span class="keyword">type</span> Driver <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Open方法会返回对数据库的连接对象（新连接）</span></span><br><span class="line">	<span class="comment">// name的值其实就是常见到的dsn串，格式需要在驱动实现中定义</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// Open也可能会返回一个已经缓存的DB连接（closed状态），其实这是不必要的</span></span><br><span class="line">	<span class="comment">// 因为sql包会自己去建立连接池去管理所有的DB空闲连接并按需进行重用和释放</span></span><br><span class="line"> </span><br><span class="line">	Open(name <span class="type">string</span>) (Conn, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Conn表示有状态的DB连接，不能在协程间共享！</span></span><br><span class="line"><span class="keyword">type</span> Conn <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 返回一个prepared statement，和这个DB连接绑定</span></span><br><span class="line">	Prepare(query <span class="type">string</span>) (Stmt, <span class="type">error</span>)</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 关闭DB连接，停止当前所有的stat执行以及事务，使得连接不再被使用</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">// 因为sql包维护了自己的连接池，调用Close会用来释放不需要的连接</span></span><br><span class="line">	<span class="comment">// 没必要在自己的驱动实现中做额外的Conn的缓存</span></span><br><span class="line">	Close() <span class="type">error</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 显式开启一个事务</span></span><br><span class="line">	Begin() (Tx, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Stmt 表示一个prepare语句 - 绑定一个DB连接并且不能被多协程共享</span></span><br><span class="line"><span class="keyword">type</span> Stmt <span class="keyword">interface</span> &#123;</span><br><span class="line"> <span class="comment">// Close 关闭Stmt - 也是为了释放其和后端DB绑定的连接.</span></span><br><span class="line"> Close() <span class="type">error</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 返回语句中占位符的数量 - 就是 &#x27;?&#x27; 的个数</span></span><br><span class="line"> <span class="comment">// 如果 &gt;= 0，sql包会在执行前对占位符参数个数进行检查</span></span><br><span class="line"> NumInput() <span class="type">int</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 执行DML/DDL语句，比如INSERT/UPDATE..（不需要返回查询结果的请求）</span></span><br><span class="line"> Exec(args []Value) (Result, <span class="type">error</span>)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 执行查询，获得查询数据集</span></span><br><span class="line"> Query(args []Value) (Rows, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于Conn类型，标准库明确了这是一个<strong>有状态的连接</strong>，Prepare()方法会显式绑定一个连接去执行SQL操作，这期间不能干别的事情，这对后面理解连接池至关重要！并发操作的协程安全是在sql包中控制的。</p>
<p>另外为了通用，绝大部分DB类型转换都在database包内进行，第三方驱动往往只要处理极个别的类型，以避免出现精度缺失&#x2F;截断，所以我们便在driver包中看到了这类接口&#x2F;函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ValueConverter是用于类型转换的接口</span></span><br><span class="line"><span class="comment">// 其提供ConvertValue方法用于将值转换为Value类型</span></span><br><span class="line"><span class="keyword">type</span> ValueConverter <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// 把v转换成Value类型</span></span><br><span class="line">	ConvertValue(v <span class="keyword">interface</span>&#123;&#125;) (Value, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Valuer提供Value方法，用于其实例转换自身为一个Value类型值</span></span><br><span class="line"><span class="keyword">type</span> Valuer <span class="keyword">interface</span> &#123;</span><br><span class="line">	Value() (Value, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个ValueConverter在driver包中预定义了多种实现，用于保持不同驱动之间一致的值类型转换，一般有如下几个使用场景：</p>
<ol>
<li>在sql包中将一个Value类型值转换成合适的DB字段类型，确保字段精度不丢失 – 比如确保int64变量可以存放于一个uint16类型的DB字段中</li>
<li>DB类型转为Value类型</li>
<li>在sql包的scan方法中，将Value值转换为用于用户自定义的变量</li>
</ol>
<h1 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h1><p>新手常见的误区便是把sql.DB对象当作一个DB连接，实际上确实对应一个连接池，创建的时候也不会立即对DB进行建链；来看下sql.DB的定义：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接池对象</span></span><br><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">	driver driver.Driver <span class="comment">// 引用driver的实现</span></span><br><span class="line">	dsn    <span class="type">string</span>        <span class="comment">// database source name</span></span><br><span class="line"> </span><br><span class="line">	numClosed <span class="type">uint64</span>     <span class="comment">// 连接池中closed状态连接的数目</span></span><br><span class="line"> </span><br><span class="line">	mu           sync.Mutex         <span class="comment">// mutex锁，保护如下对象</span></span><br><span class="line">	freeConn     []*driverConn      <span class="comment">// 保存DB连接的数组</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 保存请求的数组</span></span><br><span class="line">	<span class="comment">// 新请求过来会append，并尝试从freeConn中拿到空闲连接来执行</span></span><br><span class="line">	<span class="comment">// 连接结束后对应小表的connRequest会被关闭，对应的连接会释放</span></span><br><span class="line">	connRequests []<span class="keyword">chan</span> connRequest </span><br><span class="line">	</span><br><span class="line">	numOpen      <span class="type">int</span> <span class="comment">// 活跃/opend状态的连接数</span></span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 这个chan用于告诉sql.DB需要一个新连接了</span></span><br><span class="line">	<span class="comment">// sql.DB创建后会有一个后台的协程通过connectionOpener()函数来获取这个chan来分配连接</span></span><br><span class="line">	<span class="comment">// 会在db.Close()后关闭，并广播给connectionOpener退出</span></span><br><span class="line">	openerCh    <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	closed      <span class="type">bool</span>                   <span class="comment">// 关闭标识</span></span><br><span class="line">	dep         <span class="keyword">map</span>[finalCloser]depSet</span><br><span class="line">	lastPut     <span class="keyword">map</span>[*driverConn]<span class="type">string</span> <span class="comment">// stacktrace of last conn&#x27;s put; debug only</span></span><br><span class="line">	maxIdle     <span class="type">int</span>                    <span class="comment">// 最大空闲连接数，默认和负数都为0</span></span><br><span class="line">	maxOpen     <span class="type">int</span>                    <span class="comment">// 最大连接数，&lt;= 0表示不限制</span></span><br><span class="line">	maxLifetime time.Duration          <span class="comment">// 复用空闲连接的时间，超时便是过期连接，需要被释放</span></span><br><span class="line">	cleanerCh   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;          <span class="comment">// 和openerCh原理类似，用于释放对应的连接和依赖</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 对driver.Conn实现的二次封装</span></span><br><span class="line"><span class="comment">// 通过mutex来控制使用这个连接的操作，比如Tx、Stmt、Result、Rows</span></span><br><span class="line"><span class="comment">// 所以rows这种操作用完一定要Close，不然会导致连接不被释放，连接数增长...</span></span><br><span class="line"><span class="keyword">type</span> driverConn <span class="keyword">struct</span> &#123;</span><br><span class="line">	db        *DB       <span class="comment">// 引用DB，用来在连接失效/释放的时候告知sql.DB更新连接池记录</span></span><br><span class="line">	createdAt time.Time <span class="comment">// 创建时间</span></span><br><span class="line"> </span><br><span class="line">	sync.Mutex              <span class="comment">// mutex锁，保护下列对象</span></span><br><span class="line">	ci          driver.Conn</span><br><span class="line">	closed      <span class="type">bool</span>        <span class="comment">// 连接是否被关闭</span></span><br><span class="line">	finalClosed <span class="type">bool</span>        <span class="comment">// ci是不是失效了，如果ci.Close执行了，它的状态就是false</span></span><br><span class="line">	openStmt    <span class="keyword">map</span>[driver.Stmt]<span class="type">bool</span></span><br><span class="line"> </span><br><span class="line">	inUse      <span class="type">bool</span>     <span class="comment">// 是否被使用 </span></span><br><span class="line">	onPut      []<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="comment">// 连接被put到连接池的时候执行的操作，一般用来关闭已有的Stmt</span></span><br><span class="line">	dbmuClosed <span class="type">bool</span>     <span class="comment">// 用于removeClosedStmtLocked，一个连接上所有的Stmt都是closed状态，它就为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sql.go代码中绝大部分的篇幅都在说明如何控制连接池。sql.DB在实现上协程安全，多个Goroutine引用和执行会自行从连接池中复用空闲连接、释放无效&#x2F;过期连接，同时进行异常重试，很方便的设定，不过使用的时候要注意：</p>
<h2 id="1-设置连接池的大小"><a href="#1-设置连接池的大小" class="headerlink" title="1. 设置连接池的大小"></a>1. 设置连接池的大小</h2><p>连接池通过三个属性进行设置，分别为maxIdle（最大空闲连接）、maxOpen（最大连接数）、maxLifetime（连接过期时间），要注意他们的默认值：</p>
<ul>
<li>maxIdle：默认值为2，如果通过SetMaxIdleConns设置&lt;&#x3D;0的值的话，都表示对DB不保持空闲连接，也就是短链接，执行后立即释放；</li>
<li>maxOpen：默认为0，即无限，因为DB的连接资源有限，在突发大量DB访问或者分布式应用部署的时候很容易出现DB连接打满的情况，这种会造成访问拒绝，如果我们设置了上限，那么程序会在没有可用连接的时候等待连接池释放空闲连接在执行后续的请求，出于对DB的保护，推荐设置这个参数。</li>
<li>maxLifetime：连接池中空闲连接的过期时间，默认为0，表示不会过期；</li>
</ul>
<h2 id="2-连接的分配策略"><a href="#2-连接的分配策略" class="headerlink" title="2. 连接的分配策略"></a>2. 连接的分配策略</h2><p>连接池中的连接可能会因为网络抖动、DB端超时而失效，那下次从连接池中拿到这个driverConn的时候不能用怎么办？sql包怎么处理这种场景呢？</p>
<p>这里就涉及到sql包复用连接的策略：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接复用策略.</span></span><br><span class="line"><span class="keyword">type</span> connReuseStrategy <span class="type">uint8</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// 强制开启一个新连接.</span></span><br><span class="line">	alwaysNewConn connReuseStrategy = <span class="literal">iota</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 从连接池中获得空闲连接使用，分两种情况</span></span><br><span class="line">    <span class="comment">// 1，达到MaxOpenConns上限，等待..</span></span><br><span class="line">    <span class="comment">// 2，没有空闲连接，向driver中申请一个新的</span></span><br><span class="line">	cachedOrNewConn</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>通过以上的两种策略，sql包始终可以控制对一个失效连接（ErrBadConn）的重试，比如Exec的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(db *DB)</span></span> Exec(query <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) (Result, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">var</span> res Result</span><br><span class="line">	<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxBadConnRetries; i++ &#123;</span><br><span class="line">		res, err = db.exec(query, args, cachedOrNewConn)</span><br><span class="line">		<span class="keyword">if</span> err != driver.ErrBadConn &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> err == driver.ErrBadConn &#123;</span><br><span class="line">		<span class="keyword">return</span> db.exec(query, args, alwaysNewConn)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以这种DB操作是可以重试的….</p>
<h2 id="3-及时释放连接"><a href="#3-及时释放连接" class="headerlink" title="3. 及时释放连接"></a>3. 及时释放连接</h2><p>从driverConn的定义中可以看到，Tx、Stmt、Result、Rows这类操作是绑定连接的，如果使用完成后不关闭，会导致连接池中对应连接一直处于活跃状态，这种情况非常糟糕，比如下面情况：</p>
<ul>
<li>没有设置连接池上限，连接池资源不断分配新连接，DB连接打满…</li>
<li>设置并达到连接上限，新sql.DB操作的调用一直处于等待空闲连接，请求被无限挂起</li>
</ul>
<p>我会在后面举例说明Tx、Stmt的几个陷阱。</p>
<h2 id="4-丢失连接属性"><a href="#4-丢失连接属性" class="headerlink" title="4. 丢失连接属性"></a>4. 丢失连接属性</h2><p>永远不要假设你的SQL操作都是在一个DB连接上执行的；除非你使用Tx、Stmt，否则在使用sql.DB的时候很容易遇到一些极其隐蔽的异常，比如使用USE语句切换database，或者set字符集读取一个非UTF8的表等，这种操作只对你从连接池中取到的那个连接有效，并非全局设置，由于在sql.DB上执行了这些操作，连接在回到连接池后，有着和其他连接不相同的属性，很有可能你下次操作拿到的连接就是一个默认的database&#x2F;字符集。</p>
<p>这也是不能在sql.DB上显示使用BEGIN和COMMIT语句的原因。</p>
<h1 id="使用Prepared-Statements"><a href="#使用Prepared-Statements" class="headerlink" title="使用Prepared Statements"></a>使用Prepared Statements</h1><p>通常一个prepared statment（后面用PS代替）的执行过程为：获得一个DB连接并绑定，发送一个带占位符的statement给数据库进行编译并返回statement ID给前端，最后将参数、statement ID发送给DB执行后拿到结果；使用PS的理由多种多样，安全、性能、代码通用性等等。</p>
<p>大多数场景下都推荐使用PS，但也要注意一下潜在的问题，：</p>
<h2 id="1-并发Stmt导致连接突增"><a href="#1-并发Stmt导致连接突增" class="headerlink" title="1. 并发Stmt导致连接突增"></a>1. 并发Stmt导致连接突增</h2><p>在使用sql.DB的时候一定要记住这是一个连接池，我们只能通过Tx、DB这种的对象去使用PS，而不能单独指定一个连接去执行。</p>
<p>在sql包中，PS的执行过程如下：</p>
<ol>
<li>在连接池中绑定到一个空闲连接，执行prepare操作，返回Stmt对象（Stmt可以记住对应的连接）</li>
<li>执行时，Stmt尝试使用这个连接，但发现它已经失效或者出于busy状态时，会重复第一步，重新使用一个连接prepare</li>
</ol>
<p>如果是高并发场景，Stmt会频繁使用新连接去re-perpare，这种即会出现连接资源突增，也会不可避免的造成DB端statement大量占用，某些数据库会触发阈值保护导致请求失败；</p>
<p>其实关键还是在于PS是绑定连接执行的，实际工作环境中，很多DB后端都使用了中间层，那么这种PS请求就是一条绑定了client-&gt;proxy-&gt;DB的一条链（甚至更长）；有时候我们不在乎prepare这点性能影响，一些SQL的防控也可以在代码中控制或者由proxy拦截，可是又希望尽可能的复用各个层面的连接池（client、proxy…），那么这时候就可以少用Stmt。</p>
<p>其实这样的场景还挺多的…</p>
<h2 id="2-占位符区别"><a href="#2-占位符区别" class="headerlink" title="2. 占位符区别"></a>2. 占位符区别</h2><p>SQL语句的占位符是在驱动包中定义的！不同数据库的不一样，比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MySQL               PostgreSQL            Oracle</span><br><span class="line"><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span>               <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span>            <span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span><span class="operator">=</span></span><br><span class="line"><span class="keyword">WHERE</span> col <span class="operator">=</span> ?       <span class="keyword">WHERE</span> col <span class="operator">=</span> $<span class="number">1</span>        <span class="keyword">WHERE</span> col <span class="operator">=</span> :col</span><br><span class="line"><span class="keyword">VALUES</span>(?, ?, ?)     <span class="keyword">VALUES</span>($<span class="number">1</span>, $<span class="number">2</span>, $<span class="number">3</span>)    <span class="keyword">VALUES</span>(:val1, :val2, :val3)</span><br></pre></td></tr></table></figure>

<p>可以看到在MySQL，PG，Oracle中都不一样，所以想一份代码搞定通用的DB操作这种想法是行不通的，一些DB比如Sphinx都没有PS语句（不支持“binary” protocol），你的应用如果要访问不同类型的DB，得好好想想…</p>
<p>另外像db.Query、Exec这样的操作，如果是写了占位符的传参，比如：db.Query(“insert into t values (?,?)”, param1, param2)，也会默认使用PS，防不胜防…</p>
<h2 id="3-事务中使用PS"><a href="#3-事务中使用PS" class="headerlink" title="3. 事务中使用PS"></a>3. 事务中使用PS</h2><p>PS和Tx操作都是绑定连接执行的，如果要在事务中执行PS，需要确保其在Tx的内部进行Prepare，而且这个Stmt不能在事务外部使用。</p>
<p>那事务外prepare的Stmt能不能在Tx内使用呢？翻了下标准库后发现….居然可以！</p>
<p>通过Tx.Stmt方法就可以做到，来看示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">updateMoney, err := db.Prepare(<span class="string">&quot;UPDATE balance SET money=money+? WHERE id=?&quot;</span>)</span><br><span class="line"> ...</span><br><span class="line"> tx, err := db.Begin()</span><br><span class="line"> ...</span><br><span class="line"> res, err := tx.Stmt(updateMoney).Exec(<span class="number">123.45</span>, <span class="number">98293203</span>)</span><br></pre></td></tr></table></figure>

<p>不过这个地方强烈不建议使用它，因为在Tx中使用外部的Stmt在实际执行时，Go会创建一个事务级别的Stmt，它会把每次执行的语句在这个事务的连接上re-prepare，所以效果和在内部使用Stmt没有区别，反而增加了re-prepare的消耗；Go官方自己也意识到了这个实现不妙，所以写了TODO打算修复来着：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tx *Tx)</span></span> Stmt(stmt *Stmt) *Stmt &#123;</span><br><span class="line">	<span class="comment">// TODO(bradfitz): optimize this. Currently this re-prepares</span></span><br><span class="line">	<span class="comment">// each time.  This is fine for now to illustrate the API but</span></span><br><span class="line">	<span class="comment">// we should really cache already-prepared statements</span></span><br><span class="line">	<span class="comment">// per-Conn. See also the big comment in Tx.Prepare.</span></span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> tx.db != stmt.db &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;Stmt&#123;stickyErr: errors.New(<span class="string">&quot;sql: Tx.Stmt: statement from different database used&quot;</span>)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dc, err := tx.grabConn()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;Stmt&#123;stickyErr: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dc.Lock()</span><br><span class="line">	si, err := dc.ci.Prepare(stmt.query)</span><br><span class="line">	dc.Unlock()</span><br><span class="line">	txs := &amp;Stmt&#123;</span><br><span class="line">		db: tx.db,</span><br><span class="line">		tx: tx,</span><br><span class="line">		txsi: &amp;driverStmt&#123;</span><br><span class="line">			Locker: dc,</span><br><span class="line">			si:     si,</span><br><span class="line">		&#125;,</span><br><span class="line">		query:     stmt.query,</span><br><span class="line">		stickyErr: err,</span><br><span class="line">	&#125;</span><br><span class="line">	tx.stmts.Lock()</span><br><span class="line">	tx.stmts.v = <span class="built_in">append</span>(tx.stmts.v, txs)</span><br><span class="line">	tx.stmts.Unlock()</span><br><span class="line">	<span class="keyword">return</span> txs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以慎用…..</p>
<p>另外一个关于在事务中使用的PS的陷阱就是要注意defer的作用域，老生常谈的坑，看个<strong>错误示范</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">tx, err := db.Begin()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> tx.Rollback()</span><br><span class="line">stmt, err := tx.Prepare(<span class="string">&quot;INSERT INTO foo VALUES (?)&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> stmt.Close() <span class="comment">// 错误示范，这里defer的作用域为func！</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	_, err = stmt.Exec(i)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">err = tx.Commit()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// func结束才会执行stmt.Close()！</span></span><br></pre></td></tr></table></figure>

<p>上面的操作实际是Tx提交后，连接就释放回连接池了，但是defer由于延迟执行，在func作用域之后才会在释放这个连接上的Stmt依赖，这种会造成连接池中的空闲连接的状态不一致，如果是使用的Go 1.4之前的版本，要注意把stmt.Close()放到Tx内，比如去掉defer或者加个匿名的func。</p>
<p>当然官方在之后的版本修复了这个问题，见<a target="_blank" rel="noopener" href="https://codereview.appspot.com/131650043">CR 131650043</a>。</p>
<h1 id="使用事务Tx"><a href="#使用事务Tx" class="headerlink" title="使用事务Tx"></a>使用事务Tx</h1><p>如果你用了database&#x2F;sql包，并且希望某些操作只在一个DB连接上执行，用Tx是你唯一的选择。</p>
<p>关于Tx的建议无非是遵从它的标准方法，基本在PS环节都有提及，比如用Begin()、Commit()、RollBack()来替代显式的事务执行语句，事务内使用PS。</p>
<h2 id="1-Multiple-Statement支持"><a href="#1-Multiple-Statement支持" class="headerlink" title="1. Multiple Statement支持"></a>1. Multiple Statement支持</h2><p>database&#x2F;sql包没有明确表示支持Multiple Statement，所以一个Multiple Statement操作会由driver的实现来自行决定执行方式，结果也就难以预料，比如下面这个语句很可能由driver返回一个error，或者只执行了部分语句：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_, err := db.Exec(<span class="string">&quot;DELETE FROM tbl1; DELETE FROM tbl2&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>也不要在Tx中这么搞，牢记事务中每个SQL操作必须<strong>串行执行</strong>，这个得由开发者自己控制；同时由于绑定单个连接，对于查询的返回结果Rows这样的对象，必须被scanned&#x2F;closed后Tx才能被下一个查询使用。</p>
<p>举例一个常见的使用场景：“我要从一个表中获得所有的标识列（id），然后去另一张表里面引用这些id去做查询&#x2F;更新”，下面这个例子是可行的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rows, err := db.Query(<span class="string">&quot;select * from tbl1&quot;</span>) <span class="comment">// connection 1</span></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">	err = rows.Scan(&amp;myvariable)</span><br><span class="line">	<span class="comment">// 下面的语句并不会使用use connection 1, 因为已被Tx占用</span></span><br><span class="line">	db.Query(<span class="string">&quot;select * from tbl2 where id = ?&quot;</span>, myvariable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果我们把查询2替换成Tx查询就不行了，<strong>错误示例</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tx, err := db.Begin()</span><br><span class="line">rows, err := tx.Query(<span class="string">&quot;select * from tbl1&quot;</span>) <span class="comment">// tx&#x27;s connection</span></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">	err = rows.Scan(&amp;myvariable)</span><br><span class="line">	<span class="comment">// 错误! 连接被rows使用中</span></span><br><span class="line">	tx.Query(<span class="string">&quot;select * from tbl2 where id = ?&quot;</span>, myvariable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为rows绑定了这个连接上的操作，再次执行查询2是不能继续复用这个连接的，甚至不能执行，必须等rows关闭；第二个错误的例子会收到由driver返回的错误，以MySQL为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[MySQL] 2016/06/20 00:01:51 packets.go:384: Busy buffer</span><br><span class="line">query <span class="built_in">id</span> 2 failed: driver: bad connection</span><br></pre></td></tr></table></figure>

<p>这种场景要严格串行化对Tx的使用，或者使用连表查询的方式代替。</p>
<h2 id="2-并发场景下的Tx"><a href="#2-并发场景下的Tx" class="headerlink" title="2. 并发场景下的Tx"></a>2. 并发场景下的Tx</h2><p>紧接着上面的串行操作，Tx在使用上并非和sql.DB一样是协程安全的，这个和sql包的实现有关，Tx的SQL操作是在绑定的driverConn上执行的，虽然有原语控制driverConn的调用，但是rows这样的操作不结束，还是会出现上面一样的bad connection错误；没有rows这种依赖的就不会，比如Tx.Exec()操作就是协程安全的。</p>
<p>所以想做到在tx上并发一堆查询（Query）就要自己用mutex控制对Tx的串行化调用，并保证rows关闭后开始下一个操作；不过这种方式不推荐，存在实现难度…</p>
<p>试想这样的场景：为了提高程序的执行效率，我将计算和存储工作都放在了并发的goroutine中，每个并发的Goroutine都要查询和更新DB中的数据，于此同时为了保证整个操作的版本一致性，所有goroutine中我使用了一个Tx来保证，代码如下（忽略error处理）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">tx, _ := db.Begin() <span class="comment">// ignore errs</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">defer</span> tx.Rollback()</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		SomeWork()</span><br><span class="line">		rows, _ := tx.Query(<span class="string">&quot;select xxx&quot;</span>)</span><br><span class="line">		<span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">			<span class="comment">// ....</span></span><br><span class="line">		&#125;</span><br><span class="line">		rows.Close()</span><br><span class="line"> </span><br><span class="line">		SomeWork2()</span><br><span class="line">		_, _ := tx.Exec(<span class="string">&quot;insert into xxx&quot;</span>)</span><br><span class="line">	&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">tx.Commit()</span><br></pre></td></tr></table></figure>

<p>需求合情合理，但是这么做就会遭遇提到的busy buffer问题，怎么办？</p>
<p>我的建议是把DB看成一个单纯的存储，尽量在程序的计算完成后，对DB做一次持久化，而不是把一堆逻辑放在一起，这种还容易产生死锁。</p>
<p>可以按照下面的方法改写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// query data for workFuncs()</span></span><br><span class="line"><span class="keyword">var</span> ids []<span class="type">int</span></span><br><span class="line">rows, _ := tx.Query(<span class="string">&quot;select id from xxx&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">	<span class="keyword">var</span> id <span class="type">int</span></span><br><span class="line">	rows.Scan(&amp;id)</span><br><span class="line">	ids := <span class="built_in">append</span>(ids, id)</span><br><span class="line">&#125;</span><br><span class="line">rows.Close()</span><br><span class="line"> </span><br><span class="line"><span class="comment">// do concurrent works</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		info := SomeWork(id)</span><br><span class="line">		results &lt;- info</span><br><span class="line">	&#125;(ids)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// update data to db</span></span><br><span class="line"><span class="keyword">for</span> info := <span class="keyword">range</span> results &#123;</span><br><span class="line">	tx.Exec(<span class="string">&quot;insert into xxx values (?)&quot;</span>, info.X)</span><br><span class="line">&#125;</span><br><span class="line">tx.Commit()</span><br></pre></td></tr></table></figure>

<p>避免并发的Tx调用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是能想到的关于database&#x2F;sql包的注意点，官方的<a target="_blank" rel="noopener" href="http://go-database-sql.org/">说明文档</a>中还有一些坑这里都没有提及，因为很少遇到，比如存储过程和uint64数值，如果有这种需求，不妨多阅读一下doc。</p>
<p>尽管如此标准库还是很好用的，这部分我建议直接阅读源码，实现并不复杂，较多的篇幅都是在介绍连接池的控制，多翻翻基本就可以了解，不过重要的还是实际场景多实践，配合用例理解才能更深刻。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Ian</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://beanbee.github.io/blog/2016/usage-database-sql-golang/">https://beanbee.github.io/blog/2016/usage-database-sql-golang/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/blog/2018/quick-maunal-myqlbinlog/"><i class="fa fa-chevron-left">  </i><span>Quick Manual of mysqlbinlog</span></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://beanbee.github.io/blog/2016/usage-database-sql-golang/';
  this.page.identifier = 'blog/2016/usage-database-sql-golang/';
  this.page.title = 'database/sql包使用须知';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'beanbee' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script></div></div><footer class="footer-bg" style="background-image: url(/images/default_top_image_beanbee.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2022 By Ian</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>